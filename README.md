### 第一步：搭建TCP网桥服务器

[tag_link](https://github.com/codeHauler-1/NetProxy/tree/netBridgeServer) <br/>
**目的：**

建立一个TCP长连接一个网桥服务器,所谓的网桥，其实质就是一个TCP服务器和客户端。用来保证传递云端与终端的实时通信。这样的服务器百度有很多例子，在此不多赘述。

[bridgo.go](./bridge.go)  为部署在云端的网桥服务。

[client.go](./client.go) 部署在本地终端设备。

**思考：**

1.如何解决TCP粘包的问题？

2.客户端（终端）连接如何验证其身份？

3.是否需要指定类似HTTP协议一样的消息协议，以便于解析？

### 第二步：网桥验证和消息协议

##### 1.客户端接入验证

在生产中，客户端的接入是要被限制的。不能随便接入我们的网桥增加风险。验证身份合法性的方式有很多，我这里选择一种比较简单的方式，当客户端拨号成功获取连接后则向云端发送一段验证码，云端再验证验证码的有效性，有效则保持连接，无效则关闭连接。

##### 2.数据持久储存

在此，数据持久储存我选用了sqlite3来储存数据。使用gorm来进行操作数据库。验证码储存和传输都采用MD5 加密。<br/>
[data.go](./db/data.go) --基于gorm的model模型。

##### 3.消息协议

类似http协议一样，我们需要定一种消息协议来保证云端和客户端的正确的通信，防止漏读和粘包。 我这里采用如下方式：

|  消息类型   | 内容长度  | 内容 |
|  ----  | ----  |----|
| 4 byte | 4 byte(int32)|n byte|

[message.go](./lib/connect/message.go)--根据消息协议编写的对象

**备注：**
这次更新了很多文件，文件中都有相应的注释。在编写代码的过程中，根据实际的需要，封装了一些工具包，例如:
myerr,tools,crypt。这里lib/connect包中Conn继承net.Conn,旨在根据我们的消息协议，增加一下方法。<br/>

[server.go](./server/server.go) 服务端入口文件<br/>
[client.go](./client/client.go) 客户端入口文件<br/>

**思考：**</br>
1.现在客户端（终端）设备可以与云端发生正常通信，那么真正的访客，浏览器，ssh等怎么访问我们的终端所在的内网环境的端口服务？<br/>
2.云端如果实现消息代理？<br/>
3.终端如果实现消息代理？<br/>
4.如何保证消息代理的1对1整个链路不出错？<br/>